#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <sys/time.h>
// Code by Daniel Redington U96037486 to implement a bloom filter in CUDA
/* SipHash implementation starts here */
// used by siphash
#include <assert.h>
#include <stddef.h>
#include <inttypes.h>
#include <string.h>

/*
    SipHash reference C implementation  -- this is the same implementation provided in the additional information document 
    Copyright (c) 2012-2022 Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>
    Copyright (c) 2012-2014 Daniel J. Bernstein <djb@cr.yp.to>

    To the extent possible under law, the author(s) have dedicated all copyright
    and related and neighboring rights to this software to the public domain
    worldwide. This software is distributed without any warranty.

    You should have received a copy of the CC0 Public Domain Dedication along
    with this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
*/

/* default: SipHash-2-4 */
#ifndef cROUNDS
#define cROUNDS 2
#endif
#ifndef dROUNDS
#define dROUNDS 4
#endif

#define ROTL(x, b) ((uint64_t)(((x) << (b)) | ((x) >> (64 - (b)))))

#define U8TO64_LE(p)                                                           \
    (((uint64_t)((p)[0])) | ((uint64_t)((p)[1]) << 8) |                        \
     ((uint64_t)((p)[2]) << 16) | ((uint64_t)((p)[3]) << 24) |                 \
     ((uint64_t)((p)[4]) << 32) | ((uint64_t)((p)[5]) << 40) |                 \
     ((uint64_t)((p)[6]) << 48) | ((uint64_t)((p)[7]) << 56))

#define U64TO8_LE(p, v)                                                        \
    (p)[0] = (uint8_t)((v));                                                   \
    (p)[1] = (uint8_t)((v) >> 8);                                              \
    (p)[2] = (uint8_t)((v) >> 16);                                             \
    (p)[3] = (uint8_t)((v) >> 24);                                             \
    (p)[4] = (uint8_t)((v) >> 32);                                             \
    (p)[5] = (uint8_t)((v) >> 40);                                             \
    (p)[6] = (uint8_t)((v) >> 48);                                             \
    (p)[7] = (uint8_t)((v) >> 56);

#define SIPROUND                                                               \
    do {                                                                       \
        v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; v0 = ROTL(v0, 32);              \
        v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2;                                 \
        v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0;                                 \
        v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; v2 = ROTL(v2, 32);              \
    } while (0)

__device__ int siphash(const void *in, const size_t inlen, const void *k, uint8_t *out, const size_t outlen) {
    const uint8_t *ni = (const uint8_t *)in;
    const uint8_t *kk = (const uint8_t *)k;

    if (outlen != 8 && outlen != 16)
        return -1;

    uint64_t v0 = 0x736f6d6570736575ULL;
    uint64_t v1 = 0x646f72616e646f6dULL;
    uint64_t v2 = 0x6c7967656e657261ULL;
    uint64_t v3 = 0x7465646279746573ULL;

    uint64_t k0 = U8TO64_LE(kk);
    uint64_t k1 = U8TO64_LE(kk + 8);

    v0 ^= k0;
    v1 ^= k1;
    v2 ^= k0;
    v3 ^= k1;

    if (outlen == 16) v1 ^= 0xee;

    const uint8_t *end = ni + inlen - (inlen % 8);
    uint64_t m, b = ((uint64_t)inlen) << 56;
    int i;

    while (ni != end) {
        m = U8TO64_LE(ni);
        ni += 8;
        v3 ^= m;
        for (i = 0; i < cROUNDS; ++i) SIPROUND;
        v0 ^= m;
    }

    switch (inlen & 7) {
    case 7: b |= ((uint64_t)ni[6]) << 48;
    case 6: b |= ((uint64_t)ni[5]) << 40;
    case 5: b |= ((uint64_t)ni[4]) << 32;
    case 4: b |= ((uint64_t)ni[3]) << 24;
    case 3: b |= ((uint64_t)ni[2]) << 16;
    case 2: b |= ((uint64_t)ni[1]) << 8;
    case 1: b |= ((uint64_t)ni[0]); break;
    }

    v3 ^= b;
    for (i = 0; i < cROUNDS; ++i) SIPROUND;
    v0 ^= b;

    v2 ^= (outlen == 16) ? 0xee : 0xff;
    for (i = 0; i < dROUNDS; ++i) SIPROUND;

    b = v0 ^ v1 ^ v2 ^ v3;
    U64TO8_LE(out, b);

    if (outlen == 8) return 0;

    v1 ^= 0xdd;
    for (i = 0; i < dROUNDS; ++i) SIPROUND;
    b = v0 ^ v1 ^ v2 ^ v3;
    U64TO8_LE(out + 8, b);

    return 0;
}

/* SipHash implementation ends here */
typedef unsigned long long int intlong;   // changed the name for readibility


#define MAX_STRING_LENGTH 20        // max length of each string generated by generate_flattened_string
// definition of bloom filter
struct __align__(8) bloom_filter {
    uint8_t num_hashes;
    double error;
    intlong num_bits;
    intlong num_elements;
    int misses;
};

double ERROR;                                   // false positivity rate of the filter (determined by user)
uint64_t NUMBER_OF_ELEMENTS, STRINGS_ADDED;     // number of strings total and number of strings added to the filter

struct bloom_filter bf_h;               // bloom filters for host (cpu)
char *strings_h;            // 1D-char array for host (cpu)
uint8_t *byte_array_h;   // 1D-unsigned byte array (0 - 255) for host (cpu)
int *positions_h;         // 1D-int array for host (cpu)

struct bloom_filter *bf_d;               // bloom filters for device (gpu)
char *strings_d;            // 1D-char array for device (gpu)
uint8_t *byte_array_d;   // 1D-unsigned byte array (0 - 255) for device (gpu)
int *positions_d;         // 1D-int array for device (gpu)

float elapsed_time;                 // used to print elapsed time

__global__ void insert_bloom(struct bloom_filter *bloom, uint8_t *byte_array, char *strings, int * positions, int count) {
    // calculate thread number
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= count) return;
    // calculate string of thread
    const char *str = &strings[positions[idx]];

    uint64_t hash;
    uint8_t out[8], key[16] = {1};

    uint8_t len =0;
    while (str[len] != '\0') { len++; }

    for ( uint8_t i = 0; i < bloom->num_hashes; i++) {
        siphash(str, len, key, out, 8);
        memcpy(&hash, out, sizeof(uint64_t));
        // no need to use atomic operations as multiple values setting it to 1 is not a problem
        byte_array[hash % bloom->num_bits] = 1;
        // regenerate a new key based on the previous hash
        for (size_t j = 0; j < 16; j++) {
            ((uint8_t*)key)[j] ^= (uint8_t)(hash >> (j % 8));
        }
    }
    
}


// function to check if a string is in the bloom filter
__global__ void check_bloom(struct bloom_filter *bloom, uint8_t *byte_array, char *strings, int * positions, int count) {
    // calculate thread value
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= count) return;

    uint64_t hash;
    uint8_t out[8], key[16] = {1};
    // calculate string for thread
    const char *str = &strings[positions[idx]];

    uint8_t len =0;

    while (str[len] != '\0') { len++; }
    // start by setting found to true
    bool found = true;

    for ( uint8_t i = 0; i < bloom->num_hashes; i++) {
        siphash(str, len, key, out, 8);
        memcpy(&hash, out, sizeof(uint64_t));
        // if string not found in bloom filter, set found to false
        if (byte_array[hash % bloom->num_bits] == 0) {
            found = false;
            break;
        }
        // regenerate a new key based on the previous hash
        for (size_t j = 0; j < 16; j++) {
            ((uint8_t*)key)[j] ^= (uint8_t)(hash >> (j % 8));
        }
    }
    // if string not found atomically increment bloom filter misses 
    if (!found) {
        atomicAdd(&bloom->misses, 1);
    }
}
// These functions kept the same from cpu implementation
void init_filter(struct bloom_filter *bloom, uint64_t elements, double error) {
    bloom->error = error;
    bloom->num_elements = elements;

    bloom->num_bits = ceil((elements * log(error)) / log(1 / pow(2, log(2))));
    bloom->num_hashes = round((bloom->num_bits / elements) * log(2));
    bloom->misses = 0;
}

char get_random_character(){
    static const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    return charset[rand() % (sizeof(charset) - 1)];
}

void generate_flattened_string(int count, int max_string_length, char **flattened, int **positions){
    *positions = (int *)malloc(count * sizeof(int));
    *flattened = (char *)malloc((max_string_length + 1) * count * sizeof(char)); // Overestimate

    int current_position = 0;
    for (int i = 0; i < count; i++){
        int length = rand() % max_string_length + 1;
        (*positions)[i] = current_position;

        for (int j = 0; j < length; j++){
            (*flattened)[current_position++] = get_random_character();
        }
        // Every string is null terminated so a simple "flattened + positions[i]" works to reference the i-th string.
        (*flattened)[current_position++] = '\0';
    }

    // Realloc now that the size is known.
    *flattened = (char *)realloc(*flattened, current_position * sizeof(char));
}

int main(int argc, char **argv) {

    /* _____ COMMAND LINE ARGUMENTS _____ */
    // check arguements 
    printf("This happened\n");
    if (argc != 4) {
        printf("Invalid. Requires 3 arguments.\n");
        printf("{ # of elements } { desired %% error } { # of threads }\n\n");
        return -1;
    }

    NUMBER_OF_ELEMENTS = atoi(argv[1]);
    ERROR = atof(argv[2]);
    int BLOCK_SIZE = atoi(argv[3]);
    if ((ERROR >= 1) || (ERROR <= 0)) {
        printf("Invalid. Error must be within 0 and 1. Currently => %.3lf\n\n", ERROR);
        return -1;
    }

    STRINGS_ADDED = NUMBER_OF_ELEMENTS;
    //printf(" got here!\n");
    /* _____ GENERATE STRINGS _____ */

    srand(1);
    generate_flattened_string(NUMBER_OF_ELEMENTS, MAX_STRING_LENGTH, &strings_h, &positions_h);
    //printf( " string generated\n");
    /* _____ INITIALIZE CPU FILTER _____ */

    init_filter(&bf_h, STRINGS_ADDED, ERROR);
    byte_array_h = (uint8_t *)calloc(bf_h.num_bits, sizeof(uint8_t));
    //printf ("filter initialized\n");
    // Optional: Calculate total size of string array
    intlong size = positions_h[STRINGS_ADDED - 1] + strlen(strings_h + positions_h[STRINGS_ADDED - 1]) + 1;

    /* _____ ALLOCATE DEVICE MEMORY _____ */

    cudaMalloc(&byte_array_d, bf_h.num_bits * sizeof(uint8_t));
    cudaMemset(byte_array_d, 0, bf_h.num_bits * sizeof(uint8_t));

    cudaMalloc(&strings_d, size * sizeof(char));
    cudaMemcpy(strings_d, strings_h, size * sizeof(char), cudaMemcpyHostToDevice);

    cudaMalloc(&positions_d, NUMBER_OF_ELEMENTS * sizeof(int));
    cudaMemcpy(positions_d, positions_h, NUMBER_OF_ELEMENTS * sizeof(int), cudaMemcpyHostToDevice);

    cudaMalloc(&bf_d, sizeof(bloom_filter));
    cudaMemcpy(bf_d, &bf_h, sizeof(bloom_filter), cudaMemcpyHostToDevice);
    //printf("memory allocated\n");

    /* _____ TIMING START _____ */
    cudaEvent_t start, stop; 
    cudaEventCreate(&start);
    cudaEventCreate(&stop);
    cudaEventRecord(start, 0);
    //printf("time started\n");
    /* _____ INSERT TO FILTER ON GPU _____ */
    
    insert_bloom<<<(STRINGS_ADDED + BLOCK_SIZE) / BLOCK_SIZE, BLOCK_SIZE>>>(
        bf_d, byte_array_d, strings_d, positions_d, STRINGS_ADDED);
    //printf("inserted\n");
    /* _____ CHECK FILTER ON GPU _____ */

    check_bloom<<<(NUMBER_OF_ELEMENTS + BLOCK_SIZE) / BLOCK_SIZE, BLOCK_SIZE>>>(
        bf_d, byte_array_d, strings_d, positions_d, NUMBER_OF_ELEMENTS);
    //printf("queried\n");
    /* _____ TIMING STOP _____ */

    cudaEventRecord(stop, 0);
    cudaEventSynchronize(stop);
    cudaEventElapsedTime(&elapsed_time, start, stop);


    /* _____ DISPLAY RESULTS _____ */

    printf("[GPU] Insert+Query time: %0.3f ms\n", elapsed_time);
    cudaMemcpy(&bf_h, bf_d, sizeof(bloom_filter), cudaMemcpyDeviceToHost);
    printf("[GPU] False negatives: %d/%d\n", bf_h.misses, NUMBER_OF_ELEMENTS);


    /* _____ FREE MEMORY _____ */

    cudaFree(byte_array_h);
    cudaFree(strings_d);
    cudaFree(positions_d);
    cudaFree(bf_d);

    free(byte_array_h);
    free(strings_h);
    free(positions_h);

    return 0;
}